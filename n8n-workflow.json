{
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "multi-agent-orchestrator",
          "responseMode": "responseNode",
          "options": {}
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2.1,
        "position": [
          -288,
          80
        ],
        "id": "4f63b4b2-c098-4bd4-b13d-540c4ad6d114",
        "name": "Webhook",
        "webhookId": "11ecaef9-ae95-4f33-bf53-c42863deebad"
      },
      {
        "parameters": {
          "jsCode": "/**\n * Input Validation Module for n8n\n *\n * Validates incoming data and generates data_quality_warnings\n * to be included in orchestrator packages\n */\n\n// ============================================================================\n// VALIDATION FUNCTIONS\n// ============================================================================\n\n/**\n * Validates contact profile structure\n */\nfunction validateContactProfile(profile) {\n  const warnings = [];\n  const errors = [];\n\n  if (!profile) {\n    errors.push('contact_info is missing or null');\n    return { valid: false, warnings, errors };\n  }\n\n  if (!profile.full_name && !profile.name) {\n    warnings.push('No name information available - personalization will be limited');\n  }\n\n  if (!profile.linkedin_url) {\n    warnings.push('No LinkedIn URL - linkedin channel may be limited');\n  }\n\n  if (!profile.company) {\n    warnings.push('No company information - business context analysis will be limited');\n  }\n\n  if (!profile.job) {\n    warnings.push('No job title - role-based personalization unavailable');\n  }\n\n  return {\n    valid: errors.length === 0,\n    warnings,\n    errors\n  };\n}\n\n/**\n * Validates activities array\n */\nfunction validateActivities(activities) {\n  const warnings = [];\n  const errors = [];\n  const channelStats = {};\n\n  if (!activities || !Array.isArray(activities)) {\n    warnings.push('No activities found - analysis will be based on limited data');\n    return { warnings, errors, channelStats, hasActivities: false };\n  }\n\n  if (activities.length === 0) {\n    warnings.push('Activities array is empty - no interaction history available');\n    return { warnings, errors, channelStats, hasActivities: false };\n  }\n\n  for (const activity of activities) {\n    const type = activity.activity_type || 'UNKNOWN';\n    channelStats[type] = (channelStats[type] || 0) + 1;\n\n    if (!activity.recorded_on) {\n      warnings.push(`Activity ${activity.activity_id || 'unknown'} missing recorded_on date`);\n    }\n\n    if (!activity.direction) {\n      warnings.push(`Activity ${activity.activity_id || 'unknown'} missing direction`);\n    }\n  }\n\n  return {\n    warnings,\n    errors,\n    channelStats,\n    hasActivities: true,\n    totalActivities: activities.length\n  };\n}\n\n/**\n * Validates available communication channels from contact info\n */\nfunction validateAvailableChannels(profile) {\n  const availableChannels = [];\n  const warnings = [];\n\n  if (!profile) {\n    warnings.push('CRITICAL: No contact profile - cannot determine available channels');\n    return { availableChannels, warnings };\n  }\n\n  if (profile.linkedin_url || profile.linkedin_urn) {\n    availableChannels.push('linkedin');\n  } else {\n    warnings.push('No LinkedIn URL - linkedin channel unavailable');\n  }\n\n  if (profile.email) {\n    availableChannels.push('email');\n  }\n\n  if (profile.whatsapp_number) {\n    availableChannels.push('whatsapp');\n  }\n\n  if (profile.phone) {\n    availableChannels.push('phone');\n  }\n\n  if (availableChannels.length === 0) {\n    warnings.push('CRITICAL: No communication channels available - cannot send messages');\n  }\n\n  return {\n    availableChannels,\n    warnings\n  };\n}\n\n/**\n * Validates stats object\n */\nfunction validateStats(stats) {\n  const warnings = [];\n  const errors = [];\n\n  if (!stats) {\n    warnings.push('Stats object is missing');\n    return { warnings, errors };\n  }\n\n  if (stats.total_activities === undefined) {\n    warnings.push('total_activities count is missing from stats');\n  }\n\n  return { warnings, errors };\n}\n\n/**\n * Analyzes conversation patterns from activities\n */\nfunction analyzeConversationPatterns(activities) {\n  if (!activities || activities.length === 0) {\n    return {\n      lastInbound: null,\n      lastOutbound: null,\n      inboundCount: 0,\n      outboundCount: 0,\n      daysSinceLastContact: null,\n      conversationState: 'no_history'\n    };\n  }\n\n  let lastInbound = null;\n  let lastOutbound = null;\n  let inboundCount = 0;\n  let outboundCount = 0;\n\n  const sorted = [...activities].sort((a, b) => \n    new Date(b.recorded_on) - new Date(a.recorded_on)\n  );\n\n  for (const activity of sorted) {\n    if (activity.direction === 'INBOUND') {\n      inboundCount++;\n      if (!lastInbound) lastInbound = activity;\n    } else if (activity.direction === 'OUTBOUND') {\n      outboundCount++;\n      if (!lastOutbound) lastOutbound = activity;\n    }\n  }\n\n  const lastActivity = sorted[0];\n  const daysSinceLastContact = lastActivity \n    ? Math.floor((new Date() - new Date(lastActivity.recorded_on)) / (1000 * 60 * 60 * 24))\n    : null;\n\n  let conversationState = 'active';\n  if (daysSinceLastContact > 30) {\n    conversationState = 'stale';\n  } else if (daysSinceLastContact > 90) {\n    conversationState = 'dormant';\n  }\n\n  if (lastOutbound && (!lastInbound || new Date(lastOutbound.recorded_on) > new Date(lastInbound.recorded_on))) {\n    conversationState = 'awaiting_response';\n  }\n\n  return {\n    lastInbound,\n    lastOutbound,\n    inboundCount,\n    outboundCount,\n    daysSinceLastContact,\n    conversationState\n  };\n}\n\n// ============================================================================\n// MAIN VALIDATION FUNCTION\n// ============================================================================\n\n/**\n * Comprehensive validation of input data\n */\nfunction validateInputData(inputData) {\n  const allWarnings = [];\n  const allErrors = [];\n\n  const contactInfo = inputData.contact_info || {};\n  const activities = inputData.activities || [];\n  const stats = inputData.stats || {};\n\n  const profileValidation = validateContactProfile(contactInfo);\n  allWarnings.push(...profileValidation.warnings);\n  allErrors.push(...profileValidation.errors);\n\n  const activitiesValidation = validateActivities(activities);\n  allWarnings.push(...activitiesValidation.warnings);\n  allErrors.push(...activitiesValidation.errors);\n\n  const channelsValidation = validateAvailableChannels(contactInfo);\n  allWarnings.push(...channelsValidation.warnings);\n\n  const statsValidation = validateStats(stats);\n  allWarnings.push(...statsValidation.warnings);\n  allErrors.push(...statsValidation.errors);\n\n  const conversationAnalysis = analyzeConversationPatterns(activities);\n\n  const normalizedData = {\n    ...inputData,\n    _validation: {\n      isValid: allErrors.length === 0,\n      availableChannels: channelsValidation.availableChannels,\n      activityStats: activitiesValidation.channelStats,\n      hasActivities: activitiesValidation.hasActivities,\n      totalActivities: activitiesValidation.totalActivities || 0\n    },\n    _conversationAnalysis: conversationAnalysis,\n  };\n\n  return {\n    valid: allErrors.length === 0,\n    normalizedData,\n    data_quality_warnings: allWarnings,\n    errors: allErrors,\n    availableChannels: channelsValidation.availableChannels,\n    conversationAnalysis\n  };\n}\n\n// ============================================================================\n// N8N EXECUTION\n// ============================================================================\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const inputData = item.json;\n  const validationResult = validateInputData(inputData);\n  \n  results.push({\n    json: {\n      contact_info: inputData.contact_info,\n      activities: inputData.activities,\n      stats: inputData.stats,\n      validation: {\n        is_valid: validationResult.valid,\n        errors: validationResult.errors,\n        data_quality_warnings: validationResult.data_quality_warnings,\n        available_channels: validationResult.availableChannels\n      },\n      conversation_analysis: validationResult.conversationAnalysis,\n      _normalized: validationResult.normalizedData\n    }\n  });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -80,
          0
        ],
        "id": "7db1c27c-97d9-4de4-893b-7c43181a553c",
        "name": "Input Validator"
      },
      {
        "parameters": {
          "mode": "raw",
          "jsonOutput": "={\n  \"SEMANTIC_CONSTANTS\": {\n    \"NEVER_CONTACTED_DAYS\": null,\n    \"MIN_CONFIDENCE_THRESHOLD\": 0.6,\n    \"ACTION_CONFIDENCE_THRESHOLD\": 0.7,\n    \"UNKNOWN_STATE\": \"unknown\",\n    \"DEFAULT_CHANNEL\": \"email\",\n    \"MAX_RETRY_ITERATIONS\": 2, \n    \"TODAY_DATE\": \"{{ $today.toString() }}\"\n  },\n  \"session_id\": {{ $json.session_id ?? Math.floor(Math.random()*99999999999)}},\n  \"contact_hubspot_id\":{{ $json.body.contact_info.hubspot_id }},\n  \"iteration_count\": 1\n}",
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          -80,
          160
        ],
        "id": "ca3532db-9621-455e-bcda-b9c3f1b68e3c",
        "name": "Constants"
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3.2,
        "position": [
          288,
          16
        ],
        "id": "39fe72a3-c4e6-419c-a384-7a5cf7f4428f",
        "name": "Merge"
      },
      {
        "parameters": {
          "description": "Call this tool (Context Analyzer) for analyze relationship depth and quality for professional contacts.",
          "workflowId": {
            "__rl": true,
            "value": "AvvHbsi6znhLenHt",
            "mode": "list",
            "cachedResultUrl": "/workflow/AvvHbsi6znhLenHt",
            "cachedResultName": "Context & Relationship Analyzer"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $json.toJsonString() }}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          640,
          480
        ],
        "id": "d30296e8-56c5-4529-b147-a5fc8bda24c2",
        "name": "Context Analyzer"
      },
      {
        "parameters": {
          "description": "Call this tool (Opportunity Detector) for detect opportunities for meaningful outreach by analyzing engagement signals.",
          "workflowId": {
            "__rl": true,
            "value": "x8FhUOAPaob2UAsD",
            "mode": "list",
            "cachedResultUrl": "/workflow/x8FhUOAPaob2UAsD",
            "cachedResultName": "Opportunity Detector"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{$json.toJsonString()}}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          640,
          624
        ],
        "id": "666509ba-ed40-410f-a496-ee5b175bd5f6",
        "name": "Opportunity Detector"
      },
      {
        "parameters": {
          "description": "Call this tool (State Analyzer) for analyze the current state of conversations across all communication channels to determine who should act next.",
          "workflowId": {
            "__rl": true,
            "value": "p5j7uHQGG4MXtzDQ",
            "mode": "list",
            "cachedResultUrl": "/workflow/p5j7uHQGG4MXtzDQ",
            "cachedResultName": "State Analyzer"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $json.toJsonString() }}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          784,
          480
        ],
        "id": "e8bf58b3-6660-4c7a-831b-fdb9dca1a395",
        "name": "State Analyzer"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=Process this contact and call all analysis tools.\n\nINPUT DATA:\n{{ $json.toJsonString() }}\n\n---\n\nCURRENT DATE/TIME: {{ $now.toISO() }}\n\n---\n\nINSTRUCTIONS:\n\n1. CALL ALL 4 TOOLS in order:\n   - Context Analyzer\n   - Opportunity Detector\n   - State Analyzer\n   - Timing Strategist\n\n2. CONSOLIDATE all tool responses into your final output\n\n3. DETECT any missing data and add warnings\n\nRemember:\n- Call EACH tool exactly ONCE\n- Capture the COMPLETE response from each tool\n- Include ALL responses in wave1_results\n\n‚ö†Ô∏è CRITICAL OUTPUT FORMAT:\nYour response must be PURE JSON only.\n- NO markdown code blocks (no ```)\n- NO text before or after the JSON\n- Start with { and end with }",
          "options": {
            "systemMessage": "=You are the \"Distribution Orchestrator\" for Wave 1.\n\nYour mission:\n1. Call ALL FOUR analysis tools with that payload\n2. Collect and consolidate their results\n3. Output the combined results for Wave 2\n\n====================\nYOUR TOOLS (MUST CALL ALL 4)\n====================\n\nYou have 4 tools connected. You MUST call each one EXACTLY ONCE:\n\n| Tool Name | Purpose | Call Order |\n|-----------|---------|------------|\n| Context Analyzer | Analyze relationship depth & stage | 1st |\n| Opportunity Detector | Find engagement signals & hooks | 2nd |\n| State Analyzer | Determine conversation state & timing | 3rd |\n| Timing Strategist | Recommend optimal contact timing | 4th |\n\n‚ö†Ô∏è CRITICAL: You MUST call ALL 4 tools before producing your final output.\n‚ö†Ô∏è CRITICAL: Pass the SAME payload to each tool (the shared_payload you prepare).\n\n====================\nEXECUTION PROCESS\n====================\n\nSTEP 1: CALL EACH TOOL\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCall each tool with the shared payload.\nWait for each response before proceeding.\n\nTool 1: Context Analyzer\n‚Üí Input: shared_payload\n‚Üí Capture: full JSON response\n\nTool 2: Opportunity Detector  \n‚Üí Input: shared_payload\n‚Üí Capture: full JSON response\n\nTool 3: State Analyzer\n‚Üí Input: shared_payload\n‚Üí Capture: full JSON response\n\nTool 4: Timing Strategist\n‚Üí Input: shared_payload\n‚Üí Capture: full JSON response\n\nSTEP 2: CONSOLIDATE RESULTS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCombine all tool responses into wave1_results.\n\n====================\nINPUT STRUCTURE\n====================\n\nYou receive a JSON object containing:\n\n- contact_context\n  - contact_info: name, job, company, email, phone, linkedin_url, etc.\n  - activities[]: all interactions with this contact\n  - stats: activity counts and summaries\n\n- resources_context\n  - resources[]: available content to share\n  - events[]: upcoming events\n\n- deduplication_context\n  - recently_suggested_resources[]\n  - recently_suggested_events[]\n  - recent_attempts[]\n\n- meta\n  - now: current datetime (ISO)\n  - wave: \"wave1\"\n  - contact_timezone: IANA timezone\n\n====================\nOUTPUT FORMAT (MANDATORY)\n====================\n\nAfter calling ALL 4 tools, output this JSON structure:\n\n{\n  \"agent_id\": \"distribution_orchestrator\",\n  \"phase\": \"wave1\",\n  \"is_retry\": false,\n  \"retry_iteration\": 0,\n  \"target_agents\": [\n    \"context_relationship_analyzer\",\n    \"opportunity_detector\", \n    \"state_analyzer\",\n    \"timing_strategist\"\n  ],\n  \"shared_payload\": {\n    \"contact_context\": {},\n    \"resources_context\": {},\n    \"deduplication_context\": {},\n    \"meta\": {}\n  },\n  \"wave1_results\": {\n    \"context_relationship_analyzer\": <FULL RESPONSE FROM TOOL 1>,\n    \"opportunity_detector\": <FULL RESPONSE FROM TOOL 2>,\n    \"state_analyzer\": <FULL RESPONSE FROM TOOL 3>,\n    \"timing_strategist\": <FULL RESPONSE FROM TOOL 4>\n  },\n  \"missing_data_warnings\": [],\n  \"execution_summary\": {\n    \"tools_called\": 4,\n    \"tools_succeeded\": 4,\n    \"tools_failed\": 0,\n    \"failed_tools\": []\n  }\n}\n\n====================\nMISSING DATA DETECTION\n====================\n\nBefore calling tools, check for missing data and add warnings:\n\n| Condition | Warning to Add |\n|-----------|----------------|\n| contact_info.email is null/empty | \"no_email\" |\n| contact_info.phone is null/empty | \"no_phone\" |\n| contact_info.linkedin_url is null/empty | \"no_linkedin_url\" |\n| activities[] is empty | \"no_activities\" |\n| resources[] is empty | \"no_resources\" |\n| events[] is empty | \"no_events\" |\n\n====================\nRETRY HANDLING\n====================\n\nIf input contains retry_meta.is_retry = true:\n- Set is_retry = true\n- Set retry_iteration = retry_meta.iteration\n- Include retry_meta.retry_instructions when calling relevant tools\n- Add the instructions to the tool input as \"agent_specific_instructions\"\n\nExample for retry:\nWhen calling Opportunity Detector with retry instruction:\n{\n  \"contact_context\": {...},\n  \"resources_context\": {...},\n  \"meta\": {...},\n  \"agent_specific_instructions\": {\n    \"opportunity_detector\": \"Re-check for engagement signals in LinkedIn activities\"\n  }\n}\n\n====================\nERROR HANDLING\n====================\n\nIf a tool fails to respond or returns an error:\n1. Record the failure in execution_summary.failed_tools[]\n2. Set that tool's result to: {\"error\": \"Tool failed to respond\", \"tool_name\": \"...\"}\n3. Continue calling remaining tools\n4. Do NOT stop the entire process for one tool failure\n\n====================\nPRINCIPLES\n====================\n\n1. CALL ALL TOOLS: Never skip a tool. All 4 must be called.\n\n2. PASS-THROUGH DATA: Send contact_context, resources_context, etc. as-is to tools.\n   Do NOT modify or filter the data.\n\n3. CAPTURE FULL RESPONSES: Include the COMPLETE response from each tool in wave1_results.\n   Do NOT summarize or truncate.\n\n4. NO ANALYSIS: You do not analyze or interpret. You orchestrate and consolidate.\n\n5. SEQUENTIAL EXECUTION: Call tools in order (1‚Üí2‚Üí3‚Üí4) to ensure consistency.\n\n====================\nüö® ANTI-HALLUCINATION PROTOCOL\n====================\n\nRULE #1: wave1_results MUST contain ACTUAL tool responses, not invented data.\nRULE #2: If a tool returns an error, report the error. Do NOT invent a successful response.\nRULE #3: Copy tool responses exactly as received. Do NOT modify them.\n\nYour final output MUST be exactly one valid JSON object with the structure above."
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 2.2,
        "position": [
          496,
          16
        ],
        "id": "1649a99e-b34e-4aec-9e99-c692ad0187b6",
        "name": "Orchestrator Distribution",
        "retryOnFail": true,
        "waitBetweenTries": 500,
        "executeOnce": true
      },
      {
        "parameters": {
          "description": "Call this tool (Timing Strategist) for determine optimal timing for outreach by analyzing temporal patterns and response behaviors.\n",
          "workflowId": {
            "__rl": true,
            "value": "SA9CbSZ6gG4VbLr3",
            "mode": "list",
            "cachedResultUrl": "/workflow/SA9CbSZ6gG4VbLr3",
            "cachedResultName": "Timing Strategist"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $json.toJsonString() }}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          784,
          624
        ],
        "id": "9c909ff4-c782-412a-b186-6a109af04ddc",
        "name": "Timing Strategist"
      },
      {
        "parameters": {
          "content": "## WAVE 1\nAnalysis",
          "height": 320,
          "width": 560,
          "color": 5
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          368,
          448
        ],
        "id": "6296cc57-5a2b-414c-b1b5-288ef9d40fa1",
        "name": "Sticky Note"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "==### INPUT - Wave 1 Results:\n{{ $('Orchestrator Distribution').first().json.output }}\n---\n### HISTORICAL VALIDATED EXAMPLES (Learn from past successful decisions)\nThe following are REAL recommendations that were VALIDATED by humans. Use them as reference for tone, style, channel selection, and decision-making patterns (ignore if empty):\n{{ $('Get historial recomendations').item.json.toJsonString() ?? 'empty' }}\n\n**Guidelines for using historical examples:**\nCompare generated content TONE and STYLE against validated examples\n- Check if channel selection aligns with historically successful channels\n- Use patterns to calibrate your quality assessment\n- Flag significant deviations from successful patterns\n\n## YOUR TASK\n\n1. **CALL ALL THREE TOOLS** (Channel Selector, Content Generator, Sequence Strategist) with the Wave 1 results\n2. **CAPTURE their outputs** exactly as returned\n3. **EVALUATE** the quality of all results (Wave 1 + Wave 2)\n4. **DECIDE**: retry Wave 1 or continue to Synthesis\n\n---\n\n## CRITICAL: You MUST output valid JSON with this EXACT structure:\n\n{\n  \"agent_id\": \"evaluation_orchestrator\",\n  \"phase\": \"wave2_evaluation\",\n  \"wave2_results\": {\n    \"channel_selector\": {\n      \"raw_output\": <PASTE EXACT OUTPUT FROM CHANNEL SELECTOR TOOL>,\n      \"extracted\": {\n        \"recommended_channel\": \"linkedin|email|whatsapp|phone\",\n        \"fallback_channel\": \"...\",\n        \"channel_rationale\": \"...\",\n        \"confidence\": 0.0\n      }\n    },\n    \"content_generator\": {\n      \"raw_output\": <PASTE EXACT OUTPUT FROM CONTENT GENERATOR TOOL>,\n      \"extracted\": {\n        \"generated_content\": {\n          \"linkedin\": { \"message\": \"...\", \"tone\": \"...\" },\n          \"email\": { \"subject\": \"...\", \"body\": \"...\", \"tone\": \"...\" }\n        },\n        \"content_rationale\": \"...\",\n        \"confidence\": 0.0\n      }\n    },\n    \"sequence_strategist\": {\n      \"raw_output\": <PASTE EXACT OUTPUT FROM SEQUENCE STRATEGIST TOOL>,\n      \"extracted\": {\n        \"is_sequence\": true|false,\n        \"sequence_length\": 0,\n        \"recommended_sequence\": [],\n        \"confidence\": 0.0\n      }\n    }\n  },\n  \"evaluation_decision\": {\n    \"action\": \"continue|retry\",\n    \"retry_instructions\": {\n      \"context_relationship_analyzer\": \"specific instruction or null\",\n      \"opportunity_detector\": \"specific instruction or null\",\n      \"state_analyzer\": \"specific instruction or null\",\n      \"timing_strategist\": \"specific instruction or null\"\n    },\n    \"reasoning\": \"...\"\n  },\n  \"quality_assessment\": {\n    \"wave1_coherence\": 0.0,\n    \"wave2_coherence\": 0.0,\n    \"cross_wave_alignment\": 0.0,\n,\n    \"identified_issues\": [],\n    \"strengths\": []\n  },\n  \"historical_context\": {\n    {{ $('Get historial recomendations').item.json.toJsonString() ?? {} }}\n  }\n}\n\nCurrent iteration: {{ $('Constants').first().json.iteration_count }} of {{ $('Constants').first().json.SEMANTIC_CONSTANTS.MAX_RETRY_ITERATIONS }}\n\nIMPORTANT: \n- If current iteration >= max iterations, you MUST set action = \"continue\"\n- ALWAYS include the COMPLETE outputs from each tool in wave2_results\n- The Synthesis orchestrator DEPENDS on wave2_results to make final decisions\n- You have historical validated examples - USE THEM to calibrate quality expectations\n\n‚ö†Ô∏è CRITICAL OUTPUT FORMAT:\nYour response must be PURE JSON only.\n- NO markdown code blocks (no ```)\n- NO text before or after the JSON\n- Start with { and end with }",
          "options": {
            "systemMessage": "==# Evaluation Orchestrator\n**Role**: Wave 2 Executor + Quality Controller\n\nYou have TWO critical responsibilities:\n1. **EXECUTE Wave 2**: Call the action agents and CAPTURE their full outputs\n2. **EVALUATE**: Assess quality and decide retry/continue\n\n---\n\n## PHASE 1: EXECUTE WAVE 2 TOOLS\n\nYou MUST call these three tools IN ORDER:\n\n### Tool 1: Channel Selector\n- Purpose: Recommends best communication channel\n- Input: Pass the complete Wave 1 results\n- CAPTURE: Save the ENTIRE response\n\n### Tool 2: Content Generator  \n- Purpose: Generates messages for all channels\n- Input: Pass Wave 1 results + Channel Selector output\n- CAPTURE: Save the ENTIRE response\n\n### Tool 3: Sequence Strategist\n- Purpose: Determines if multi-touch sequence needed\n- Input: Pass Wave 1 results + previous tool outputs\n- CAPTURE: Save the ENTIRE response\n\n**CRITICAL**: The Synthesis Orchestrator CANNOT function without the complete outputs from these tools. You MUST include them in wave2_results.\n\n---\n\n## PHASE 2: EVALUATE QUALITY\n\nAfter calling all tools, assess:\n\n### Wave 1 Quality Check\n- Are confidence levels adequate? (‚â•0.6 acceptable, ‚â•0.7 good)\n- Are analyses coherent with each other?\n- Are there contradictions between agents?\n\n### Wave 2 Quality Check  \n- Did Channel Selector provide a valid channel?\n- Did Content Generator produce messages for the recommended channel?\n- Does Sequence Strategist plan align with relationship stage?\n\n### Cross-Wave Alignment\n- Does channel selection match state analysis?\n- Does content leverage identified opportunities?\n- Is timing recommendation feasible?\n\n### Historical Pattern Alignment\nYou have been provided with REAL validated examples from past successful decisions. You MUST use them to:\n**1. Calibrate Quality Expectations**\n- Compare confidence levels against historically successful recommendations\n- Check if analysis depth matches what worked before\n**2. Validate Channel Selection**\n- Does the recommended channel align with historically successful channels?\n- If deviating, is there strong context-specific justification?\n\n\nIF you have been provided with REAL validated examples as user input from past successful decisions. You MUST use them to:\n\n**1. Calibrate Quality Expectations**\n- Compare confidence levels against historically successful recommendations\n- Check if analysis depth matches what worked before\n\n**2. Validate Channel Selection**\n- Does the recommended channel align with historically successful channels?\n- If deviating, is there strong context-specific justification?\n\n**3. Assess Content Quality**\n- Does generated message tone match historically validated tones?\n- Is the style consistent with what received positive feedback?\n- Are personalization elements similar to successful examples?\n\n**4. Score Historical Alignment**\n- Set historical_alignment score (0.0-1.0) based on how well current outputs match successful patterns\n- Document specific alignments and deviations in pattern_match_assessment\n\n---\n\n## PHASE 3: DECIDE\n\n### RETRY when (AND iteration < max):\n- Critical contradictions in Wave 1 results\n- Key patterns were missed\n- Analyses are too shallow/generic\n- You can provide SPECIFIC improvement instructions\n\n### CONTINUE when:\n- Results are coherent and complementary\n- Sufficient foundation for Synthesis\n- iteration >= max (MANDATORY continue)\n- Marginal gains dont justify retry cost\n- Results align reasonably with historical patterns (historical_alignment >= 0.6) <- IF NOT EMPTY\n\n---\n\n## RETRY INSTRUCTIONS FORMAT\n\nIf retry, provide SPECIFIC instructions:\n\n‚úÖ GOOD: \"Re-evaluate relationship warmth: 3 LinkedIn messages in 10 days with 2h avg response time indicates WARM not COLD\"\n‚úÖ GOOD: \"Missed signals: contact liked 5 AI posts. Match with AI case studies.\"\n\n‚ùå BAD: \"Try again with more attention\" (too vague)\n‚ùå BAD: \"Analyze better\" (not actionable)\n\n---\n\n## OUTPUT REQUIREMENTS\n\nYour response MUST be:\n1. Valid JSON (no markdown, no backticks, no extra text)\n2. Include ALL tool outputs in wave2_results\n3. Include evaluation_decision with action and reasoning\n4. Include quality_assessment with scores\n5. Include historical_context summarizing\n\nThe Synthesis Orchestrator will use wave2_results to make the final decision. If wave2_results is empty or incomplete, the entire workflow fails.\n\n====================\nüö® ANTI-HALLUCINATION PROTOCOL (MANDATORY)\n====================\n\nRULE #1: SOURCE OF TRUTH = THIS JSON ONLY\nYou must NEVER affirm a fact that is not present or directly deducible from the JSON provided.\n\n| ALLOWED | FORBIDDEN |\n|---------|-----------|\n| Quote a value present in JSON | Invent a value not present |\n| Deduce a fact from JSON data (e.g., calculated delay) | Assume unverifiable info |\n| Write \"NOT_FOUND\" or \"UNKNOWN\" if field is absent | Fill a field with invented value |\n| Summarize content from metadata.body | Interpret intent beyond the text |\n\nRULE #2: EVIDENCE TRAIL (MANDATORY)\nFor EVERY claim you make, you MUST be able to point to the exact JSON path.\n\nExample of GOOD evidence:\n\\`\\`\\`\nClaim: \"Last OUTBOUND was on 2025-08-27\"\nEvidence: activities[0].recorded_on = \"2025-08-27T12:02:43+00:00\"\n          activities[0].direction = \"OUTBOUND\" ‚úì\n\\`\\`\\`\n\nExample of BAD (hallucination):\n\\`\\`\\`\nClaim: \"Contact showed interest in pricing\"\nEvidence: ??? (not explicitly stated in any INBOUND message)\n‚Üí THIS IS HALLUCINATION - FORBIDDEN\n\\`\\`\\`\n\nRULE #3: WHEN IN DOUBT, LEAVE IT OUT\nIf you cannot point to a specific JSON field for a claim ‚Üí DO NOT MAKE THE CLAIM."
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 2.2,
        "position": [
          1184,
          32
        ],
        "id": "2a5eeb73-89a6-426a-b3f1-003ce866d759",
        "name": "Orchestrator Evaluation",
        "executeOnce": true
      },
      {
        "parameters": {
          "content": "## WAVE 2\nAction",
          "height": 320,
          "width": 560,
          "color": 3
        },
        "type": "n8n-nodes-base.stickyNote",
        "typeVersion": 1,
        "position": [
          1088,
          464
        ],
        "id": "95a8fd81-2ab6-494c-9bc3-81400b2cb351",
        "name": "Sticky Note1"
      },
      {
        "parameters": {
          "description": "Call this tool (Channel Selector) for analyze relationship context, conversation state, and channel performance to recommend where to reach out.",
          "workflowId": {
            "__rl": true,
            "value": "IranprNKAkWymI1n",
            "mode": "list",
            "cachedResultUrl": "/workflow/IranprNKAkWymI1n",
            "cachedResultName": "Channel Selector"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $('Webhook').item.json.body.toJsonString() }}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          1328,
          496
        ],
        "id": "cd1b91c8-0a56-4a6c-8e29-8a7ca6a6597b",
        "name": "Channel Selector"
      },
      {
        "parameters": {
          "description": "Call this tool (Content Generator) for You generate messages for ALL possible channels.",
          "workflowId": {
            "__rl": true,
            "value": "SD8ssifoO3WmgV6E",
            "mode": "list",
            "cachedResultUrl": "/workflow/SD8ssifoO3WmgV6E",
            "cachedResultName": "Content Generator"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $('Webhook').item.json.body.toJsonString() }}",
              "recomendations": "={{ JSON.stringify($('Get historial recomendations').all()) }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              },
              {
                "id": "recomendations",
                "displayName": "recomendations",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          1328,
          640
        ],
        "id": "0d3e86ed-e521-48e2-bf93-9691ee8ae389",
        "name": "Content Generator"
      },
      {
        "parameters": {
          "description": "Call this tool (Sequence Strategist) for determine if outreach should be standalone or part of a multi-touch sequence.",
          "workflowId": {
            "__rl": true,
            "value": "9yaALVGtzyMSW3tm",
            "mode": "list",
            "cachedResultUrl": "/workflow/9yaALVGtzyMSW3tm",
            "cachedResultName": "Sequence Strategist"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "query": "={{ $('Webhook').item.json.body.toJsonString() }}"
            },
            "matchingColumns": [
              "query"
            ],
            "schema": [
              {
                "id": "query",
                "displayName": "query",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string",
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          }
        },
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "typeVersion": 2.2,
        "position": [
          1504,
          496
        ],
        "id": "c4ba5bd4-3995-4ff5-b74f-4871e0b60445",
        "name": "Sequence Strategist"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "==### WAVE 1 RESULTS (Analysis Phase):\n{{ $('Orchestrator Distribution').first().json.output }}\n---\n### WAVE 2 RESULTS (Action Phase):\n{{ $('Orchestrator Evaluation').first().json.output }}\n---\n### CONTACT INFO:\n{{ $('Input Validator').first().json.contact_info }}\n---\n### TODAY'S DATE: {{ $today.toString() }}\n---\n\n## YOUR TASK\nSynthesize ALL agent results into ONE final actionable recommendation.\nConsider these inputs in order of priority:\n1. **Wave 1 analysis**: Relationship stage, opportunities, conversation state, optimal timing\n2. **Wave 2 actions**: Selected channel, generated content, sequence strategy\n3. **Historical patterns**: What worked before with similar contacts (if examples available)\n4. **Contact context**: Specific situation and communication history\nYou MUST output valid JSON with this EXACT structure (no markdown, no backticks):\n{\n  \"orchestrator_id\": \"orchestrator_synthesis\",\n  \"phase\": \"synthesis\",\n  \"final_decision\": {\n    \"contact_fullname\": \"...\",\n    \"action\": \"send_message|schedule_call|wait|no_action\",\n    \"selected_channel\": \"linkedin|email|whatsapp|phone\",\n    \"selected_content\": {\n      \"message\": \"...\",\n      \"subject\": \"...\" (only for email),\n      \"tone\": \"...\",\n      \"content_source\": \"wave2_content_generator\"\n    },\n    \"execution_timing\": {\n      \"execute_at\": \"ISO8601 datetime\",\n      \"timezone\": \"...\",\n      \"timing_rationale\": \"...\"\n    },\n    \"sequence_instructions\": {\n      \"is_part_of_sequence\": true|false,\n      \"current_step\": 1,\n      \"total_steps\": 0,\n      \"sequence_plan\": []\n    },\n    \"rationale\": {\n      \"overall_strategy\": \"...\",\n      \"channel_reasoning\": \"...\",\n      \"content_reasoning\": \"...\",\n      \"timing_reasoning\": \"...\",\n      \"sequence_reasoning\": \"...\",\n      \"historical_alignment\": \"How this decision aligns with past validated examples (or 'No historical data' if none)\",\n      \"confidence_factors\": {\n        \"relationship_clarity\": 0.0,\n        \"opportunity_strength\": 0.0,\n        \"channel_certainty\": 0.0,\n        \"content_quality\": 0.0,\n        \"timing_accuracy\": 0.0,\n        \"historical_pattern_match\": 0.0\n      }\n    },\n    \"risk_factors\": [],\n    \"success_criteria\": {\n      \"immediate\": \"...\",\n      \"short_term\": \"...\",\n      \"medium_term\": \"...\"\n    }\n  },\n  \"metadata\": {\n    \"synthesis_confidence\": 0.0,\n    \"agents_consulted\": {\n      \"wave_1\": [\"context_analyzer\", \"opportunity_detector\", \"state_analyzer\", \"timing_strategist\"],\n      \"wave_2\": [\"channel_selector\", \"content_generator\", \"sequence_strategist\"]\n    },\n    \"iterations_total\": 0,\n    \"processing_notes\": \"...\"\n  }\n}\n\n‚ö†Ô∏è CRITICAL OUTPUT FORMAT:\nYour response must be PURE JSON only.\n- NO markdown code blocks (no ```)\n- NO text before or after the JSON\n- Start with { and end with }",
          "options": {
            "systemMessage": "=# Orchestrator Synthesis: Final Decision Maker\n\n**ROLE**: Strategic Synthesizer & Final Authority\n\nYou receive results from 7 specialized agents across 2 waves and must produce ONE final actionable recommendation.\n\n---\n\n## INPUT STRUCTURE\n\n### Wave 1 Results (from Distribution Orchestrator)\nContains analysis from 4 agents called as tools. Look for their outputs in the tool call results:\n\n- **Context Analyzer**: relationship_stage, depth_score, trajectory, confidence\n- **Opportunity Detector**: opportunities[], strength_score, confidence  \n- **State Analyzer**: global_state, action_requirement, who_has_ball, confidence\n- **Timing Strategist**: optimal_send_window, timing_rationale, confidence\n\n### Wave 2 Results (from Evaluation Orchestrator)\nContains action recommendations in `wave2_results`:\n```json\n{\n  \"wave2_results\": {\n    \"channel_selector\": {\n      \"extracted\": {\n        \"recommended_channel\": \"...\",\n        \"fallback_channel\": \"...\",\n        \"confidence\": 0.0\n      }\n    },\n    \"content_generator\": {\n      \"extracted\": {\n        \"generated_content\": {\n          \"linkedin\": { \"message\": \"...\", \"tone\": \"...\" },\n          \"email\": { \"subject\": \"...\", \"body\": \"...\", \"tone\": \"...\" }\n        },\n        \"confidence\": 0.0\n      }\n    },\n    \"sequence_strategist\": {\n      \"extracted\": {\n        \"is_sequence\": true|false,\n        \"recommended_sequence\": [],\n        \"confidence\": 0.0\n      }\n    }\n  },\n  \"quality_assessment\": {\n    \"historical_alignment\": 0.0\n  },\n  \"historical_context\": {\n    \"examples_reviewed\": 0,\n    \"has_historical_data\": true|false,\n    \"pattern_match_assessment\": \"...\",\n    \"channel_alignment\": \"...\",\n    \"tone_alignment\": \"...\"\n  }\n}\n```\n\n### Historical Validation (Pre-processed by Evaluation)\nThe Evaluation Orchestrator has already compared results against historical validated examples. Use `historical_context` from Wave 2 results to:\n- Understand how well current recommendations align with past successes\n- Incorporate historical_alignment score into your confidence factors\n- Reference pattern_match_assessment in your rationale\n\n---\n\n## SYNTHESIS PROCESS\n\n### Step 1: Extract Key Insights\n\nFrom Wave 1:\n- Relationship stage and trajectory (Context Analyzer)\n- Best opportunities to leverage (Opportunity Detector)\n- Who should act and urgency level (State Analyzer)\n- Optimal timing window (Timing Strategist)\n\nFrom Wave 2:\n- Recommended channel + fallback (Channel Selector)\n- Generated messages for each channel (Content Generator)\n- Sequence plan if applicable (Sequence Strategist)\n- Historical alignment assessment (quality_assessment + historical_context)\n\n### Step 2: Validate Alignment\n\nCheck for consistency:\n- Does channel selection align with state analysis?\n- Does content leverage the identified opportunities?\n- Is the sequence appropriate for relationship stage?\n- Does timing match behavioral patterns?\n- Did Evaluation confirm historical pattern alignment?\n\n### Step 3: Select Best Options\n\n**Channel Selection**:\n1. Use Channel Selector recommendation\n2. Verify channel is available in contact_info\n3. If unavailable, use fallback_channel\n4. Consider historical_context.channel_alignment\n5. Document reasoning\n\n**Content Selection**:\n1. Get message from Content Generator for selected channel\n2. Verify it references opportunities from Wave 1\n3. Ensure tone matches relationship stage\n4. Consider historical_context.tone_alignment\n5. Use EXACTLY as generated (dont rewrite)\n\n**Timing Selection**:\n1. Use Timing Strategist optimal window\n2. Convert to ISO8601 with correct timezone\n3. If \"immediate\", use today date within the time window\n\n**Sequence Selection**:\n1. Use Sequence Strategist recommendation\n2. Include full sequence_plan with dates\n3. Mark step 1 as \"ready_to_execute\"\n\n### Step 4: Build Final Decision\n\nCombine everything into the output structure with:\n- Clear action and channel\n- EXACT content from Content Generator\n- Specific execution datetime\n- Complete sequence plan\n- Detailed rationale for each decision\n- Historical alignment summary from Evaluation\n- Risk factors and success criteria\n\n---\n\n## CRITICAL RULES\n\n1. **USE WAVE 2 CONTENT**: The message in `selected_content.message` MUST come from `wave2_results.content_generator.extracted.generated_content[selected_channel]`. Do NOT invent new messages.\n\n2. **VALIDATE CHANNEL AVAILABILITY**: Check that selected_channel exists in contact_info (linkedin_url, email, whatsapp_number, phone).\n\n3. **PRESERVE CONFIDENCE SCORES**: Copy confidence values from each agent into `confidence_factors`.\n\n4. **USE HISTORICAL CONTEXT**: Reference `historical_context` from Evaluation in your `historical_alignment` rationale and `historical_pattern_match` confidence factor.\n\n5. **COMPLETE SEQUENCE PLAN**: If is_sequence=true, include ALL steps with specific ISO8601 dates.\n\n6. **VALID JSON ONLY**: No markdown backticks, no extra text, just the JSON object.\n\n---\n\n## EXAMPLE MAPPING\n\nIf Wave 2 contains:\n```json\n\"channel_selector\": {\n  \"extracted\": { \"recommended_channel\": \"linkedin\", \"confidence\": 0.83 }\n}\n\"content_generator\": {\n  \"extracted\": {\n    \"generated_content\": {\n      \"linkedin\": { \n        \"message\": \"Bonjour Franck, suite √† notre √©change...\", \n        \"tone\": \"professional-friendly\" \n      }\n    }\n  }\n}\n\"historical_context\": {\n  \"has_historical_data\": true,\n  \"pattern_match_assessment\": \"Channel and tone align well with 3 similar CIO contacts\",\n  \"channel_alignment\": \"LinkedIn matches 80% of historical successes for CIO roles\"\n}\n```\n\nThen your output MUST have:\n```json\n\"selected_channel\": \"linkedin\",\n\"selected_content\": {\n  \"message\": \"Bonjour Franck, suite √† notre √©change...\",\n  \"tone\": \"professional-friendly\",\n  \"content_source\": \"wave2_content_generator\"\n}\n\"rationale\": {\n  \"historical_alignment\": \"Channel and tone align well with historical CIO patterns (80% linkedin success rate)\"\n}\n\"confidence_factors\": {\n  \"channel_certainty\": 0.83,\n  \"historical_pattern_match\": 0.8\n}\n\"metadata\": {\n  \"historical_validation_performed\": true\n}\n```\n\n====================\nOUTPUT COHERENCE RULES (MANDATORY)\n====================\n\nBefore finalizing output, validate:\n\n1) ACTION vs EXECUTE_AT COHERENCE:\n   - If action = \"wait\" AND message is empty ‚Üí execute_at should be null\n   - Use \"re_evaluate_at\" for future review dates without sending\n   - If action = \"send_message\" ‚Üí message MUST NOT be empty\n\n2) CONTENT_QUALITY VALIDATION:\n   - If message is empty ‚Üí content_quality = null (not a number)\n   - If message exists ‚Üí content_quality must reflect actual quality\n\n3) GHOSTING LEADS TO NO_ACTION:\n   - If consecutive_outbound_without_reply >= 3 ‚Üí action should be \"no_action\"\n   - Exception: break_up message (requires explicit flag)\n\n4) ACTION TYPE CLARITY:\n   - \"send_message\": Execute immediately or at execute_at\n   - \"wait\": Re-evaluate later (use re_evaluate_at, not execute_at)\n   - \"no_action\": Do nothing, flag for manual review if needed\n   - \"break_up\": Send final respectful message\n\n---\n\n## OUTPUT CHECKLIST\n\nBefore responding, verify:\n- [ ] selected_channel matches Channel Selector recommendation (or valid fallback)\n- [ ] selected_content.message is EXACTLY from Content Generator (not invented)\n- [ ] execute_at is valid ISO8601 with timezone\n- [ ] sequence_plan has specific dates (not relative times)\n- [ ] All confidence_factors are populated from agent outputs\n- [ ] historical_alignment references Evaluation historical_context\n- [ ] historical_pattern_match reflects Evaluation quality_assessment.historical_alignment\n- [ ] risk_factors identifies at least 1-2 potential issues\n- [ ] JSON is valid (no trailing commas, proper quotes)\n\n---\n\n## LANGUAGE\n\n- If contact communication history is in French, write rationale in French\n- If in English, write in English\n- Message content should match the language used by Content Generator\n\n====================\nüö® ANTI-HALLUCINATION PROTOCOL (MANDATORY)\n====================\n\nRULE #1: SOURCE OF TRUTH = THIS JSON ONLY\nYou must NEVER affirm a fact that is not present or directly deducible from the JSON provided.\n\n| ALLOWED | FORBIDDEN |\n|---------|-----------|\n| Quote a value present in JSON | Invent a value not present |\n| Deduce a fact from JSON data (e.g., calculated delay) | Assume unverifiable info |\n| Write \"NOT_FOUND\" or \"UNKNOWN\" if field is absent | Fill a field with invented value |\n| Summarize content from metadata.body | Interpret intent beyond the text |\n\nRULE #2: EVIDENCE TRAIL (MANDATORY)\nFor EVERY claim you make, you MUST be able to point to the exact JSON path.\n\nExample of GOOD evidence:\n\\`\\`\\`\nClaim: \"Last OUTBOUND was on 2025-08-27\"\nEvidence: activities[0].recorded_on = \"2025-08-27T12:02:43+00:00\"\n          activities[0].direction = \"OUTBOUND\" ‚úì\n\\`\\`\\`\n\nExample of BAD (hallucination):\n\\`\\`\\`\nClaim: \"Contact showed interest in pricing\"\nEvidence: ??? (not explicitly stated in any INBOUND message)\n‚Üí THIS IS HALLUCINATION - FORBIDDEN\n\\`\\`\\`\n\nRULE #3: WHEN IN DOUBT, LEAVE IT OUT\nIf you cannot point to a specific JSON field for a claim ‚Üí DO NOT MAKE THE CLAIM."
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 2.2,
        "position": [
          1904,
          48
        ],
        "id": "f8956e24-e9ea-482b-93c7-9a155f191362",
        "name": "Orchestrator Synthesis",
        "executeOnce": true
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "claude-sonnet-4-20250514",
            "mode": "list",
            "cachedResultName": "Claude Sonnet 4"
          },
          "options": {
            "temperature": 0.4
          }
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
        "typeVersion": 1.3,
        "position": [
          496,
          192
        ],
        "id": "7c153553-5dd5-47cc-9e53-a45bfbd4995f",
        "name": "Sonnet 4 Model",
        "credentials": {
          "anthropicApi": {
            "id": "WR9IYE0cy2Srym3w",
            "name": "Anthropic account"
          }
        }
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "claude-opus-4-1-20250805",
            "mode": "list",
            "cachedResultName": "Claude Opus 4.1"
          },
          "options": {
            "temperature": 0.8
          }
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
        "typeVersion": 1.3,
        "position": [
          1904,
          224
        ],
        "id": "4fc8a0a6-a901-4e20-8a8e-5a19da203d3f",
        "name": "Opus Model",
        "credentials": {
          "anthropicApi": {
            "id": "WR9IYE0cy2Srym3w",
            "name": "Anthropic account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Obtener el output raw del agente\nconst rawOutput = $input.first().json.output;\n\n// Limpiar los backticks de markdown si existen\nlet cleanJson = rawOutput;\nif (typeof rawOutput === 'string') {\n  cleanJson = rawOutput\n    .replace(/```json\\n?/g, '')\n    .replace(/```\\n?/g, '')\n    .trim();\n}\n\n// Parsear el JSON\nlet input;\ntry {\n  input = typeof cleanJson === 'string' ? JSON.parse(cleanJson) : cleanJson;\n} catch (e) {\n  const jsonMatch = cleanJson.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    input = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('Could not parse Synthesis output: ' + e.message);\n  }\n}\n\nconst decision = input.final_decision;\n\nif (!decision) {\n  throw new Error('Missing final_decision in Synthesis output');\n}\n\n// Obtener datos del owner y contacto\nlet ownerName = '';\nlet contactLinkedinUrl = '';\n\n// Intentar desde Webhook\ntry {\n  const webhookData = $('Webhook').first().json;\n  \n  // LinkedIn del CONTACTO (de contact_info)\n  contactLinkedinUrl = webhookData.body?.contact_info?.linkedin_url || '';\n  \n  // Nombre del OWNER (de la primera activity)\n  const activities = webhookData.body?.activities || [];\n  for (const activity of activities) {\n    if (activity.owner && activity.owner.owner_name) {\n      ownerName = activity.owner.owner_name;\n      break;\n    }\n  }\n} catch (e) {\n  // Si falla Webhook, intentar desde Merge\n  try {\n    const mergeData = $('Merge').first().json;\n    \n    contactLinkedinUrl = mergeData.contact_info?.linkedin_url || '';\n    \n    const activities = mergeData.activities || [];\n    for (const activity of activities) {\n      if (activity.owner && activity.owner.owner_name) {\n        ownerName = activity.owner.owner_name;\n        break;\n      }\n    }\n  } catch (e2) {\n    console.log('Could not extract data from any source');\n  }\n}\n\nreturn {\n  json: {\n    decision: {\n      // Identificaci√≥n\n      orchestrator_id: input.orchestrator_id || 'Not specified',\n      phase: input.phase || 'Not specified',\n      contact_fullname: decision.contact_fullname || '',\n      \n      // Owner y Contact info\n      owner_name: ownerName || 'Not specified',\n      contact_linkedin_url: contactLinkedinUrl || 'Not specified',\n      \n      // Acci√≥n principal\n      action: decision.action || 'Not specified',\n      selected_channel: decision.selected_channel || 'Not specified',\n      \n      // Contenido seleccionado\n      message: decision.selected_content?.message || 'No recommended message.',\n      subject: decision.selected_content?.subject  || '',\n      tone: decision.selected_content?.tone || '',\n      content_source: decision.selected_content?.content_source || '',\n      \n      // Timing de ejecuci√≥n\n      execute_at: decision.execution_timing?.execute_at || 'Not specified',\n      timezone: decision.execution_timing?.timezone || 'Not specified',\n      timing_rationale: decision.execution_timing?.timing_rationale || 'Not specified',\n      \n      // Secuencia\n      is_part_of_sequence: decision.sequence_instructions?.is_part_of_sequence || false,\n      current_step: decision.sequence_instructions?.current_step || 1,\n      total_steps: decision.sequence_instructions?.total_steps || 1,\n      sequence_plan: decision.sequence_instructions?.sequence_plan || [],\n      \n      // Rationale\n      overall_strategy: decision.rationale?.overall_strategy || '',\n      channel_reasoning: decision.rationale?.channel_reasoning || '',\n      content_reasoning: decision.rationale?.content_reasoning || '',\n      timing_reasoning: decision.rationale?.timing_reasoning || '',\n      sequence_reasoning: decision.rationale?.sequence_reasoning || '',\n      \n      // Confidence factors\n      relationship_clarity: decision.rationale?.confidence_factors?.relationship_clarity || 0,\n      opportunity_strength: decision.rationale?.confidence_factors?.opportunity_strength || 0,\n      channel_certainty: decision.rationale?.confidence_factors?.channel_certainty || 0,\n      content_quality: decision.rationale?.confidence_factors?.content_quality || 0,\n      timing_accuracy: decision.rationale?.confidence_factors?.timing_accuracy || 0,\n      \n      // Riesgos y criterios\n      risk_factors: decision.risk_factors || [],\n      success_criteria_immediate: decision.success_criteria?.immediate || '',\n      success_criteria_short_term: decision.success_criteria?.short_term || '',\n      success_criteria_medium_term: decision.success_criteria?.medium_term || '',\n      \n      // Metadata\n      synthesis_confidence: input.metadata?.synthesis_confidence || 0,\n      agents_wave_1: input.metadata?.agents_consulted?.wave_1 || [],\n      agents_wave_2: input.metadata?.agents_consulted?.wave_2 || [],\n      iterations_total: input.metadata?.iterations_total || 0,\n      processing_notes: input.metadata?.processing_notes || ''\n    }\n  }\n};"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2208,
          48
        ],
        "id": "26131a77-d569-4528-b24b-af2d06e0566e",
        "name": "Parse JSON"
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 2
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.decision.action }}",
                      "rightValue": "retry",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "a788d6c5-ff93-4a48-902c-006a5c83018d"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "retry"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 2
                  },
                  "conditions": [
                    {
                      "id": "7f05ea6d-271e-4628-8501-2d96b7092df8",
                      "leftValue": "={{ $json.decision.action }}",
                      "rightValue": "continue",
                      "operator": {
                        "type": "string",
                        "operation": "equals",
                        "name": "filter.operator.equals"
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "continue"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.3,
        "position": [
          1648,
          32
        ],
        "id": "5e12d69c-e0be-4d7a-a8be-1d686a203527",
        "name": "Retry?"
      },
      {
        "parameters": {
          "jsCode": "// Parse Evaluation Decision\n// Este nodo extrae la decisi√≥n de retry/continue del Evaluation Orchestrator\n\nconst evaluationOutput = $input.first().json;\nconst constants = $('Constants').first().json;\n\n// Extraer el output del agente (puede venir en .output o .text)\nlet rawOutput = evaluationOutput.output || evaluationOutput.text || '';\n\n// Intentar parsear si es JSON\nlet parsedDecision = null;\nlet action = 'continue'; // default\nlet retryInstructions = {};\n\ntry {\n  // Si el output es string, buscar JSON\n  if (typeof rawOutput === 'string') {\n    const jsonMatch = rawOutput.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      parsedDecision = JSON.parse(jsonMatch[0]);\n    }\n  } else if (typeof rawOutput === 'object') {\n    parsedDecision = rawOutput;\n  }\n\n  // Extraer la decisi√≥n\n  if (parsedDecision) {\n    // Buscar indicadores de retry en el output\n    const outputStr = JSON.stringify(parsedDecision).toLowerCase();\n    \n    // Detectar si hay retry expl√≠cito\n    if (parsedDecision.evaluation_decision?.action === 'retry' ||\n        parsedDecision.action === 'retry' ||\n        outputStr.includes('\"retry\"') && outputStr.includes('instruction')) {\n      action = 'retry';\n    }\n    \n    // Extraer retry instructions si existen\n    retryInstructions = parsedDecision.evaluation_decision?.retry_instructions ||\n                        parsedDecision.retry_instructions || {};\n  }\n} catch (e) {\n  console.log('Parse error:', e.message);\n}\n\n// Verificar l√≠mite de iteraciones\nconst currentIteration = constants.iteration_count || 1;\nconst maxIterations = constants.SEMANTIC_CONSTANTS?.MAX_RETRY_ITERATIONS || 2;\n\n// Forzar continue si alcanzamos el m√°ximo\nif (currentIteration >= maxIterations) {\n  action = 'continue';\n}\n\nreturn {\n  json: {\n    decision: {\n      action: action,\n      current_iteration: currentIteration,\n      max_iterations: maxIterations,\n      should_retry: action === 'retry' && currentIteration < maxIterations,\n      retry_instructions: retryInstructions\n    },\n    evaluation_output: evaluationOutput,\n    wave1_results: $('Orchestrator Distribution').first().json,\n    parsed_decision: parsedDecision\n  }\n};"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1472,
          32
        ],
        "id": "cfd69364-0cfb-4934-8082-1fe866f191b3",
        "name": "Parse Evaluation Decision"
      },
      {
        "parameters": {
          "jsCode": "// Prepare Retry Context\n// Prepara el contexto para re-ejecutar Wave 1 con instrucciones de mejora\n\nconst input = $input.first().json;\n\n// Obtener datos originales - buscar en m√∫ltiples fuentes posibles\nlet originalData;\ntry {\n  // Intentar obtener del Input Validator (m√°s confiable)\n  originalData = $('Input Validator').first().json;\n} catch (e) {\n  // Fallback al Merge\n  originalData = $('Merge').first().json;\n}\n\nlet originalConstants;\ntry {\n  originalConstants = $('Constants').first().json;\n} catch (e) {\n  originalConstants = {\n    SEMANTIC_CONSTANTS: { MAX_RETRY_ITERATIONS: 2 },\n    session_id: Date.now(),\n    iteration_count: 1\n  };\n}\n\n// Incrementar contador\nconst newIterationCount = (input.decision.current_iteration || 1) + 1;\n\n// Construir el contexto de retry\nconst retryContext = {\n  // Datos del contacto (desde Input Validator)\n  contact_info: originalData.contact_info,\n  activities: originalData.activities,\n  stats: originalData.stats,\n  validation: originalData.validation,\n  conversation_analysis: originalData.conversation_analysis,\n  _normalized: originalData._normalized,\n  \n  // Constants actualizados\n  SEMANTIC_CONSTANTS: originalConstants.SEMANTIC_CONSTANTS,\n  session_id: originalConstants.session_id,\n  iteration_count: newIterationCount,\n  \n  // Meta de retry - CR√çTICO para que Distribution lo detecte\n  retry_meta: {\n    is_retry: true,\n    iteration: newIterationCount,\n    max_iterations: originalConstants.SEMANTIC_CONSTANTS?.MAX_RETRY_ITERATIONS || 2,\n    previous_wave1_results: input.wave1_results?.output || {},\n    retry_instructions: input.decision.retry_instructions || {},\n    retry_reason: \"Evaluation Orchestrator requested retry for improved analysis\"\n  }\n};\n\nreturn { json: retryContext };"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1648,
          -176
        ],
        "id": "2534228c-45a0-464a-b7ff-54518f542338",
        "name": "Prepare Retry Context"
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Merge').last().json.session_id }}",
          "tableName": "n8n_orchestrator_synthesis",
          "contextWindowLength": 2000
        },
        "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
        "typeVersion": 1.3,
        "position": [
          2000,
          320
        ],
        "id": "91c23484-5e2e-4c0d-b033-0efe10d912a4",
        "name": "AI_sales_agents Memory",
        "credentials": {
          "postgres": {
            "id": "9t3LCP46SMBNPxAk",
            "name": "AI_sales_agents Supabase"
          }
        }
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Merge').last().json.session_id }}",
          "tableName": "n8n_orchestrator_evaluation",
          "contextWindowLength": 2000
        },
        "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
        "typeVersion": 1.3,
        "position": [
          1280,
          304
        ],
        "id": "338fc586-8252-460a-a7a2-d4fdf46570f1",
        "name": "AI_sales_agents Memory1",
        "credentials": {
          "postgres": {
            "id": "9t3LCP46SMBNPxAk",
            "name": "AI_sales_agents Supabase"
          }
        }
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Merge').last().json.session_id }}",
          "tableName": "n8n_orchestrator_distribution",
          "contextWindowLength": 2000
        },
        "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
        "typeVersion": 1.3,
        "position": [
          592,
          288
        ],
        "id": "3b4a9f41-030b-4509-a88f-c56669a486f5",
        "name": "AI_sales_agents Memory2",
        "credentials": {
          "postgres": {
            "id": "9t3LCP46SMBNPxAk",
            "name": "AI_sales_agents Supabase"
          }
        }
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={\n  \"message\": \"Workflow was started! This process takes about 7 minutes, please wait...\",\n  \"session_id\": \"{{ $json.session_id }}\"\n}",
          "options": {}
        },
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.4,
        "position": [
          112,
          160
        ],
        "id": "5fe5291a-fbef-4644-bf31-ee5476163c0e",
        "name": "Respond to Webhook with session_id"
      },
      {
        "parameters": {
          "tableId": "final_decision",
          "fieldsUi": {
            "fieldValues": [
              {
                "fieldId": "session_id",
                "fieldValue": "={{ $('Merge').last().json.session_id }}"
              },
              {
                "fieldId": "decision",
                "fieldValue": "={{ $json.decision }}"
              },
              {
                "fieldId": "contact_hubspot_id",
                "fieldValue": "={{ $('Merge').last().json.contact_hubspot_id }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          2416,
          48
        ],
        "id": "7c5f9684-de40-42ee-b88a-2a423d595c07",
        "name": "Save final decision into table",
        "retryOnFail": true,
        "credentials": {
          "supabaseApi": {
            "id": "7YYll9c7CXOe1KjY",
            "name": "AI_Sales_supabase"
          }
        }
      },
      {
        "parameters": {
          "operation": "update",
          "tableId": "n8n_orchestrator_synthesis",
          "matchType": "allFilters",
          "filters": {
            "conditions": [
              {
                "keyName": "session_id",
                "condition": "eq",
                "keyValue": "={{ $('Merge').last().json.session_id }}"
              }
            ]
          },
          "fieldsUi": {
            "fieldValues": [
              {
                "fieldId": "final_decision",
                "fieldValue": "={{ $json.decision }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          2416,
          -144
        ],
        "id": "a3a98a26-b1c1-4653-90ad-6cce96e026ac",
        "name": "Save final decision reference",
        "credentials": {
          "supabaseApi": {
            "id": "7YYll9c7CXOe1KjY",
            "name": "AI_Sales_supabase"
          }
        }
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://hooks.zapier.com/hooks/catch/23843453/ufit1aq/",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ $json }}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 0,
                "batchInterval": 0
              }
            }
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2624,
          48
        ],
        "id": "d581ef05-2fea-423f-b582-e8bac6685c30",
        "name": "Send to Zapier for Slack"
      },
      {
        "parameters": {
          "operation": "getAll",
          "tableId": "final_decision",
          "limit": 10,
          "filterType": "string",
          "filterString": "and=(user_slack_message.not.is.null,user_slack_message.neq.,type_of_validation.not.is.null,type_of_validation.neq.)&order=created_at.desc"
        },
        "type": "n8n-nodes-base.supabase",
        "typeVersion": 1,
        "position": [
          816,
          112
        ],
        "id": "00252f08-7852-4eac-a500-923ace280c19",
        "name": "Get historial recomendations",
        "executeOnce": true,
        "alwaysOutputData": true,
        "credentials": {
          "supabaseApi": {
            "id": "7YYll9c7CXOe1KjY",
            "name": "AI_Sales_supabase"
          }
        }
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3.2,
        "position": [
          976,
          32
        ],
        "id": "613a7cef-5871-46f8-970a-fb8979dec526",
        "name": "Merge2"
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "claude-opus-4-5-20251101",
            "mode": "list",
            "cachedResultName": "Claude Opus 4.5"
          },
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
        "typeVersion": 1.3,
        "position": [
          1184,
          208
        ],
        "id": "483c92aa-0d8c-489b-a62b-071e0428595c",
        "name": "Opus 4.5 Model2",
        "credentials": {
          "anthropicApi": {
            "id": "WR9IYE0cy2Srym3w",
            "name": "Anthropic account"
          }
        }
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Input Validator",
              "type": "main",
              "index": 0
            },
            {
              "node": "Constants",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Input Validator": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Constants": {
        "main": [
          [
            {
              "node": "Respond to Webhook with session_id",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge": {
        "main": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Context Analyzer": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Opportunity Detector": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "State Analyzer": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Orchestrator Distribution": {
        "main": [
          [
            {
              "node": "Get historial recomendations",
              "type": "main",
              "index": 0
            },
            {
              "node": "Merge2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Timing Strategist": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Orchestrator Evaluation": {
        "main": [
          [
            {
              "node": "Parse Evaluation Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Channel Selector": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Content Generator": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Sequence Strategist": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Orchestrator Synthesis": {
        "main": [
          [
            {
              "node": "Parse JSON",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Sonnet 4 Model": {
        "ai_languageModel": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Opus Model": {
        "ai_languageModel": [
          [
            {
              "node": "Orchestrator Synthesis",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Parse JSON": {
        "main": [
          [
            {
              "node": "Save final decision reference",
              "type": "main",
              "index": 0
            },
            {
              "node": "Save final decision into table",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Retry?": {
        "main": [
          [
            {
              "node": "Prepare Retry Context",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Orchestrator Synthesis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Evaluation Decision": {
        "main": [
          [
            {
              "node": "Retry?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Retry Context": {
        "main": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "AI_sales_agents Memory": {
        "ai_memory": [
          [
            {
              "node": "Orchestrator Synthesis",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "AI_sales_agents Memory1": {
        "ai_memory": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "AI_sales_agents Memory2": {
        "ai_memory": [
          [
            {
              "node": "Orchestrator Distribution",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "Respond to Webhook with session_id": {
        "main": [
          [
            {
              "node": "Merge",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Save final decision into table": {
        "main": [
          [
            {
              "node": "Send to Zapier for Slack",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Save final decision reference": {
        "main": [
          []
        ]
      },
      "Get historial recomendations": {
        "main": [
          [
            {
              "node": "Merge2",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Merge2": {
        "main": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Opus 4.5 Model2": {
        "ai_languageModel": [
          [
            {
              "node": "Orchestrator Evaluation",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      }
    },
    "pinData": {},
    "meta": {
      "templateCredsSetupCompleted": true,
      "instanceId": "68281001cf81541d7dbe4d9b4209e0b29467134afcd3e5ae5b83989067eba263"
    }
  }